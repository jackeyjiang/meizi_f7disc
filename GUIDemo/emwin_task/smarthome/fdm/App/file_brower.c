/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "stm32f10x.h"
#include "gui.h"
#include "jack_emwin.h"
#include "ff.h"
#include "ltk_debug.h"
#include "user_sd.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
// USER START (Optionally insert additional defines)
#define _DF1S	0x81
#define BROWSER_FILE_NAME_LEN 	100							//文件名长度，如果检测到文件名超过50 则丢弃这个文件 
#define BROWSER_PATH_LEN		50
#define FILE_LIST_PATH 			"0:/filelist.txt"	//文件记录列表文件的目录
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
static FRESULT result;
static FIL	listfile;
static UINT bw;	
static WM_HWIN hOpenfile;
static char *txtBuffer=0;
static char* record_file=0;
WM_HWIN hDialog;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateBrowser[] = {
  { FRAMEWIN_CreateIndirect, "FileBrower", 0, 0, 0, 320, 240, 0, 0x0, 0 },
  { TREEVIEW_CreateIndirect, "TreeView", GUI_ID_TREEVIEW0, 0, 0, 310, 200,  0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
extern WM_HWIN CreatePrintFileWaring(void);

/*********************************************************************
*
*       对话框回调函数
*/
static void _cbOpenfile(WM_MESSAGE * pMsg) {
//  WM_HWIN  hItem;
//  hItem = pMsg->hWin;
  switch (pMsg->MsgId) {
	case WM_DELETE:
		ltk_printf("Openfile delete\n");
		//WM_BringToBottom(hItem);
		//WM_BringToTop(hDialog);
		WM_ShowWindow(hDialog);
	break;
	default:
	  WM_DefaultProc(pMsg);
  }
}
/**
  * @brief  OpenFileProcess打开文件	// TBD jpg显示不正常 
	*					
  * @param  none
  * @retval none
  */
extern WM_HWIN    _ChooseFrame; 
char curentopenfile[BROWSER_FILE_NAME_LEN]={0}; //当前正在打印的文件名
static void OpenFileProcess(int sel_num,char* record_file)
{
	result = f_open (&listfile, FILE_LIST_PATH, FA_READ|FA_OPEN_EXISTING); //打开索引文件
	if(result != FR_OK)
	  return ;
	result = f_lseek (&listfile, sel_num*BROWSER_FILE_NAME_LEN);
	if(result != FR_OK)
	  return ;
	result = f_read (&listfile, curentopenfile, BROWSER_FILE_NAME_LEN, &bw);	
	if(result != FR_OK)
	  return ;
	//printf("\nfileItem=:%s",openfile);
	f_close (&listfile);
    
    if(strstr(curentopenfile,".gcode")||strstr(curentopenfile,".GCODE")
        ||strstr(curentopenfile,".g")||strstr(curentopenfile,".G")) //判断是否是gcode文件，可以执行打印指令
    {
        //对话框显示是否打印该文件
        _ChooseFrame = CreatePrintFileWaring();
        WM_MakeModal(_ChooseFrame);
    }
#if 0    
	else if(strstr(openfile,".txt")||strstr(openfile,".TXT")
			||strstr(openfile,".c")||strstr(openfile,".c")
				||strstr(openfile,".cpp")||strstr(openfile,".CPP")
						||strstr(openfile,".h")||strstr(openfile,".h"))//判断是否可以使用txt格式打开
	{
		//printf("\ntxt file");
		WM_HideWindow(hDialog);
		hOpenfile=FRAMEWIN_CreateEx(0,0,320,240,WM_HBKWIN,WM_CF_SHOW,0,0,0,_cbOpenfile);
		FRAMEWIN_SetTextColor(hOpenfile,GUI_DARKGRAY);
		FRAMEWIN_SetTitleHeight(hOpenfile, 20);
		FRAMEWIN_SetText(hOpenfile,framename);
		FRAMEWIN_SetTextAlign(hOpenfile, GUI_TA_LEFT | GUI_TA_VCENTER);
		FRAMEWIN_AddCloseButton(hOpenfile,FRAMEWIN_BUTTON_RIGHT,0);
		hWin=MULTIEDIT_CreateEx(5,22,295,230,hOpenfile,
							WM_CF_SHOW,MULTIEDIT_CF_AUTOSCROLLBAR_V|MULTIEDIT_CF_READONLY,0,0,0);
		MULTIEDIT_SetBkColor(hWin,MULTIEDIT_CI_READONLY,GUI_WHITE);
		MULTIEDIT_SetWrapWord(hWin);
		MULTIEDIT_AddText(hWin,txtBuffer);
	}
#endif
	else
	{				
		GUI_MessageBox("Sorry,do not support open the file!","Sorry",GUI_MESSAGEBOX_CF_MODAL);
	}
    
}


/**
  * @brief  scan_files 递归扫描sd卡内的文件
  * @param  path:初始扫描路径 file_name：指向用来存储文件名的一段空间 hFile:用于记录文件路径的文件指针 hTree 目录树 hNode 目录结点
	*					hTree == NULL &&	hNode == NULL 的话，不创建目录树			
  * @retval result:文件系统的返回值
  */
static FRESULT scan_files (char* path,char* file_name,FIL *hFile,WM_HWIN hTree, TREEVIEW_ITEM_Handle hNode,int *fileNum) 
{ 
		
	FRESULT res; 		          //部分在递归过程被修改的变量，不用全局变量	
	FILINFO fno; 
	static uint32_t rw_num = 0;			//已读或已写的字节数
	//char showname[60]={0};
	DIR dir; 
	int i; 
	char *fn; 	
	TREEVIEW_ITEM_Handle hItem=0;

	
#if _USE_LFN 
	static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1]; 	//长文件名支持
	fno.lfname = lfn; 
	fno.lfsize = sizeof(lfn); 
#endif 

	res = f_opendir(&dir, path);                            //打开目录
	if (res == FR_OK) 
	{ 
		i = strlen(path); 
		for (;;) 
		{ 
			res = f_readdir(&dir, &fno); 										//读取目录下的内容
			if (res != FR_OK || fno.fname[0] == 0) break; 	//为空时表示所有项目读取完毕，跳出
#if _USE_LFN 
			fn = *fno.lfname ? fno.lfname : fno.fname; 
#else 
			fn = fno.fname; 
#endif 
			if (*fn == '.') continue; 											//点表示当前目录，跳过			
			if (fno.fattrib & AM_DIR) 
			{ 																							//目录，递归读取
							
				if(hTree != NULL &&	hNode != NULL)
				{
					//hItem = TREEVIEW_ITEM_Create(TREEVIEW_ITEM_TYPE_NODE,showname,0);
					hItem = TREEVIEW_ITEM_Create(TREEVIEW_ITEM_TYPE_NODE,fn,0);						//目录，创建结点
					TREEVIEW_AttachItem(hTree,hItem,hNode,TREEVIEW_INSERT_FIRST_CHILD);		//把结点加入到目录树中
				}
								
				sprintf(&path[i], "/%s", fn); 							//合成完整目录名
				res = scan_files(path,file_name,hFile,hTree,hItem,fileNum);		//递归遍历 
				if (res != FR_OK) 
					break; 																		//打开失败，跳出循环
				path[i] = 0; 
			} 
			else 																														//是文件
			{ 				
				/* 根据要求是否创建目录树 */
				if(hTree != NULL &&	hNode != NULL)																			//创建目录树
				{
					//hItem = TREEVIEW_ITEM_Create(TREEVIEW_ITEM_TYPE_LEAF,showname,0);
					hItem = TREEVIEW_ITEM_Create(TREEVIEW_ITEM_TYPE_LEAF,fn,0);						//文件，创建树叶
					TREEVIEW_AttachItem(hTree,hItem,hNode,TREEVIEW_INSERT_FIRST_CHILD);		//把树叶添加到目录树
			
				
					if (strlen(path)+strlen(fn)<BROWSER_FILE_NAME_LEN)
					{
						sprintf(file_name, "%s/%s", path,fn); 	
						
						//存储文件名到filelist(含路径)										
						res = f_lseek (hFile, hItem*BROWSER_FILE_NAME_LEN);  
						res = f_write (hFile, file_name, BROWSER_FILE_NAME_LEN, &rw_num);	
						//printf("\nfileItem=%ld:%s",hItem,file_name);
					}			
				}
		   }//else
		} //for
	} 
	return res; 
    
} 


/**
  * @brief  Fill_FileList处理非递归过程，然后调用递归函数scan_files扫描目录
	*					
  * @param  path:初始扫描路径
  * @retval none
  */
void Fill_FileList(char* path,char* record_file,WM_HWIN hTree, TREEVIEW_ITEM_Handle hNode,int *p)
{
	char  p_path[BROWSER_FILE_NAME_LEN]={0};									//目录名 指针
	char  file_name[BROWSER_FILE_NAME_LEN]={0};								//用于存储的目录文件名，
	result = f_unlink(record_file);//删除旧的filelist		// TBD 增加自建目录
	result = f_open (&listfile, record_file, FA_READ|FA_WRITE|FA_CREATE_ALWAYS ); //打开创建索引文件
	if(result != FR_OK)
	return ;

	strcpy(p_path,path);						//复制目录名到指针
	
	result = scan_files(p_path,file_name,&listfile,hTree,hNode,p);			//递归扫描文件		
	
	f_close (&listfile);					//关闭索引文件	

}
// USER END
/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogBrowser(WM_MESSAGE * pMsg) {
	TREEVIEW_ITEM_Handle hNode;			//结点句柄
	TREEVIEW_ITEM_INFO ItemInfo;
	WM_HWIN                hItem;
	int                    NCode;
	int                    Id;
	// USER START (Optionally insert additional variables)
    SCROLLBAR_Handle       hScrollbar;
	// USER END

	switch (pMsg->MsgId) {
	case WM_DELETE:
		ltk_printf("Browserapp delete\n");
        record_file=0;
        _CreateFrame(&_cbIndex);
	break;
	case WM_INIT_DIALOG:
		//
		// Initialization of 'Browser'
		//
		hItem = pMsg->hWin;
		FRAMEWIN_SetTextColor(hItem,GUI_WHITE);
		FRAMEWIN_SetFont(hItem, GUI_FONT_20B_ASCII);
		FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
		FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
//      FRAMEWIN_AddMaxButton(hItem, FRAMEWIN_BUTTON_RIGHT, 1);
//      FRAMEWIN_AddMinButton(hItem, FRAMEWIN_BUTTON_RIGHT, 2);
		FRAMEWIN_SetTitleHeight(hItem, 25);
		//
		// Initialization of 'FileTree'
		//
        GUI_UC_SetEncodeNone();
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TREEVIEW0);
        TREEVIEW_SetFont(hItem,&GUI_FontHZ16);
//		TREEVIEW_SetAutoScrollH(hItem,1);
//		TREEVIEW_SetAutoScrollV(hItem,1);
        hScrollbar = SCROLLBAR_CreateAttached(hItem,SCROLLBAR_CF_VERTICAL);  //创建窗口的子控件
        SCROLLBAR_SetWidth(hScrollbar,20); //设置滚动条宽度为20
		TREEVIEW_SetSelMode(hItem, TREEVIEW_SELMODE_ROW);  //使用自动滚动条
		hNode = TREEVIEW_InsertItem(hItem, TREEVIEW_ITEM_TYPE_NODE, 0, 0, "SDCard[0:]");
		// USER START (Optionally insert additional code for further widget initialization)
        if( SD_OK !=  c_sdReader_init()) ltk_printf("sd card init failed\r\n");
		Fill_FileList("0:",record_file,hItem,hNode,NULL);
		TREEVIEW_ITEM_Expand(hNode);
		// USER END
	break;
	case WM_NOTIFY_PARENT:
		Id    = WM_GetId(pMsg->hWinSrc);
		NCode = pMsg->Data.v;
		switch(Id) {
		case GUI_ID_TREEVIEW0: // Notifications sent by 'FileTree'
            switch(NCode) {
            case WM_NOTIFICATION_CLICKED:
            break;
            case WM_NOTIFICATION_RELEASED:
                // USER START (Optionally insert code for reacting on notification message)
                //printf("\n release\n");				
                /* 查看选中了哪个项目 */
                hNode = TREEVIEW_GetSel(pMsg->hWinSrc);						
                /* 获取该项目的信息 */
                TREEVIEW_ITEM_GetInfo(hNode,&ItemInfo);

                if(ItemInfo.IsNode == 0)        //点击的是目录树的叶子（即文件）
                {
                    //printf("\r\nleaf num =%ld",hNode);
                    OpenFileProcess(hNode,record_file);
                }
                //		else										        //结点
                //		{					
                //			printf("\r\nnode num =%ld",hNode);
                //		}
                // USER END
            break;
            case WM_NOTIFICATION_MOVED_OUT:
                // USER START (Optionally insert code for reacting on notification message)
                // USER END
            break;
            case WM_NOTIFICATION_SEL_CHANGED:
                // USER START (Optionally insert code for reacting on notification message)
                // USER END
            break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
        break;
		// USER START (Optionally insert additional code for further Ids)
		// USER END
        }
    break;
	// USER START (Optionally insert additional message handling)
	// USER END
	default:
	WM_DefaultProc(pMsg);
		break;
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateBrowser
*/
void CreateFileBrower(void)
{
	record_file=FILE_LIST_PATH;
	hDialog=GUI_CreateDialogBox(_aDialogCreateBrowser, GUI_COUNTOF(_aDialogCreateBrowser), _cbDialogBrowser, WM_HBKWIN, 0, 0);
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
